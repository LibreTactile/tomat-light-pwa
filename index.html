<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibration PWA</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Vibration PWA">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“³</text></svg>">
    
    <!-- Apple Touch Icon -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect width='180' height='180' fill='%231a1a2e'/><text x='90' y='130' font-size='90' text-anchor='middle' fill='white'>ðŸ“³</text></svg>">
    
    <!-- Web App Manifest  -->
    <link rel="manifest" href="./manifest.json">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            touch-action: none; /* Prevent default touch behaviors */
        }

        .container {
            text-align: center;
            padding: 2rem;
            z-index: 2;
        }

        .title {
            color: #e94560;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.3);
            animation: glow 2s ease-in-out infinite alternate;
        }

        .subtitle {
            color: #a8a8a8;
            font-size: 1.1rem;
            margin-bottom: 3rem;
            opacity: 0.8;
        }

        .vibrate-button {
            width: 200px;
            height: 200px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(145deg, #e94560, #c73650);
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 10px 30px rgba(233, 69, 96, 0.3),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
        }

        .vibrate-button:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .vibrate-button.hover:before {
            left: 100%;
        }

        .vibrate-button.hover {
            transform: scale(1.05);
            box-shadow: 
                0 15px 40px rgba(233, 69, 96, 0.4),
                inset 0 2px 10px rgba(255, 255, 255, 0.2);
        }

        .vibrate-button.active {
            transform: scale(0.95);
            background: linear-gradient(145deg, #c73650, #a82d42);
            box-shadow: 
                0 5px 20px rgba(233, 69, 96, 0.5),
                inset 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .button-text {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .button-icon {
            font-size: 3rem;
            animation: pulse 2s infinite;
        }

        .status {
            margin-top: 2rem;
            color: #64ffda;
            font-size: 1rem;
            min-height: 1.5rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .status.show {
            opacity: 1;
        }

        .debug-info {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: rgba(26, 26, 46, 0.9);
            color: #64ffda;
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 0.7rem;
            font-family: monospace;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            max-width: 200px;
        }

        .debug-info.show {
            opacity: 1;
        }

        .install-prompt {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            right: 2rem;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 69, 96, 0.3);
            border-radius: 16px;
            padding: 1.5rem;
            color: white;
            text-align: center;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .install-prompt.show {
            transform: translateY(0);
            opacity: 1;
        }

        .install-button {
            background: linear-gradient(145deg, #e94560, #c73650);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.3s ease;
        }

        .install-button:hover {
            background: linear-gradient(145deg, #c73650, #a82d42);
            transform: translateY(-2px);
        }

        .close-button {
            background: transparent;
            color: #a8a8a8;
            border: 1px solid rgba(168, 168, 168, 0.3);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.3s ease;
        }

        .service-worker-status {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: rgba(26, 26, 46, 0.9);
            color: #64ffda;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .service-worker-status.show {
            opacity: 1;
        }

        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }

        .wave {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(233, 69, 96, 0.1) 0%, transparent 70%);
            animation: wave-expand 3s infinite;
        }

        @keyframes glow {
            to {
                text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes wave-expand {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(4);
                opacity: 0;
            }
        }

        .vibrating {
            animation: shake 0.1s infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0) scale(0.95); }
            25% { transform: translateX(-2px) scale(0.95); }
            75% { transform: translateX(2px) scale(0.95); }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 2rem;
            }
            
            .vibrate-button {
                width: 160px;
                height: 160px;
                font-size: 1rem;
            }
            
            .button-icon {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>
    
    <div class="container">
        <h1 class="title">Vibration PWA</h1>
        <p class="subtitle">Slide your finger into the button area to vibrate</p>
        
        <button class="vibrate-button" id="vibrateBtn">
            <div class="button-text">
                <span class="button-icon">ðŸ“³</span>
                <span>VIBRATE</span>
            </div>
        </button>
        
        <div class="status" id="status"></div>
    </div>

    <div class="debug-info" id="debugInfo"></div>

    <div class="install-prompt" id="installPrompt">
        <h3 style="margin-bottom: 1rem;">Install Vibration PWA</h3>
        <p style="margin-bottom: 1rem; opacity: 0.8;">Add this app to your home screen for the best experience!</p>
        <button class="install-button" id="installBtn">Install App</button>
        <button class="close-button" id="closeBtn">Maybe Later</button>
    </div>

    <div class="service-worker-status" id="swStatus"></div>

    <script>
        class VibrationPWA {
            constructor() {
                this.vibrateBtn = document.getElementById('vibrateBtn');
                this.status = document.getElementById('status');
                this.debugInfo = document.getElementById('debugInfo');
                this.installPrompt = document.getElementById('installPrompt');
                this.installBtn = document.getElementById('installBtn');
                this.closeBtn = document.getElementById('closeBtn');
                this.swStatus = document.getElementById('swStatus');
                
                // Touch tracking system
                this.activeTouches = new Map(); // Maps touch identifier to touch state
                this.isVibrating = false;
                this.vibrationInterval = null;
                this.deferredPrompt = null;
                this.isInstalled = false;
                this.debugMode = false; // Set to true for debugging
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.checkVibrationSupport();
                this.setupPWA();
                this.createBackgroundAnimation();
                this.checkIfInstalled();
                this.handleUrlActions();
            }

            setupEventListeners() {
                // Global touch events to track finger movement anywhere on screen
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                document.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));

                // Mouse events for desktop testing
                document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // PWA install events
                this.installBtn.addEventListener('click', () => {
                    this.installPWA();
                });

                this.closeBtn.addEventListener('click', () => {
                    this.hideInstallPrompt();
                });

                // Handle app state changes
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.stopAllVibration();
                    }
                });

                // Handle service worker updates
                window.addEventListener('load', () => {
                    this.checkForServiceWorkerUpdates();
                });

                // Debug toggle (double tap title)
                let tapCount = 0;
                document.querySelector('.title').addEventListener('click', () => {
                    tapCount++;
                    if (tapCount === 2) {
                        this.debugMode = !this.debugMode;
                        this.updateDebugInfo();
                        tapCount = 0;
                    }
                    setTimeout(() => tapCount = 0, 500);
                });
            }

            handleTouchStart(e) {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    const isInside = this.isTouchInsideButton(touch);
                    
                    this.activeTouches.set(touch.identifier, {
                        isInside: isInside,
                        x: touch.clientX,
                        y: touch.clientY
                    });

                    if (isInside) {
                        this.onTouchEnterButton(touch.identifier);
                    }
                }

                this.updateDebugInfo();
            }

            handleTouchMove(e) {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    if (this.activeTouches.has(touch.identifier)) {
                        const touchState = this.activeTouches.get(touch.identifier);
                        const wasInside = touchState.isInside;
                        const isInside = this.isTouchInsideButton(touch);

                        // Update touch position
                        touchState.x = touch.clientX;
                        touchState.y = touch.clientY;
                        touchState.isInside = isInside;

                        // Handle enter/exit events
                        if (!wasInside && isInside) {
                            this.onTouchEnterButton(touch.identifier);
                        } else if (wasInside && !isInside) {
                            this.onTouchExitButton(touch.identifier);
                        }
                    }
                }

                this.updateDebugInfo();
            }

            handleTouchEnd(e) {
                for (let touch of e.changedTouches) {
                    if (this.activeTouches.has(touch.identifier)) {
                        const touchState = this.activeTouches.get(touch.identifier);
                        
                        if (touchState.isInside) {
                            this.onTouchExitButton(touch.identifier);
                        }
                        
                        this.activeTouches.delete(touch.identifier);
                    }
                }

                this.updateDebugInfo();
            }

            // Mouse events for desktop (simulate single touch)
            handleMouseDown(e) {
                const isInside = this.isMouseInsideButton(e);
                
                this.activeTouches.set('mouse', {
                    isInside: isInside,
                    x: e.clientX,
                    y: e.clientY
                });

                if (isInside) {
                    this.onTouchEnterButton('mouse');
                }

                this.updateDebugInfo();
            }

            handleMouseMove(e) {
                if (this.activeTouches.has('mouse')) {
                    const touchState = this.activeTouches.get('mouse');
                    const wasInside = touchState.isInside;
                    const isInside = this.isMouseInsideButton(e);

                    touchState.x = e.clientX;
                    touchState.y = e.clientY;
                    touchState.isInside = isInside;

                    if (!wasInside && isInside) {
                        this.onTouchEnterButton('mouse');
                    } else if (wasInside && !isInside) {
                        this.onTouchExitButton('mouse');
                    }

                    this.updateDebugInfo();
                }
            }

            handleMouseUp(e) {
                if (this.activeTouches.has('mouse')) {
                    const touchState = this.activeTouches.get('mouse');
                    
                    if (touchState.isInside) {
                        this.onTouchExitButton('mouse');
                    }
                    
                    this.activeTouches.delete('mouse');
                }

                this.updateDebugInfo();
            }

            isTouchInsideButton(touch) {
                const rect = this.vibrateBtn.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const radius = rect.width / 2;

                const distance = Math.sqrt(
                    Math.pow(touch.clientX - centerX, 2) + 
                    Math.pow(touch.clientY - centerY, 2)
                );

                return distance <= radius;
            }

            isMouseInsideButton(e) {
                const rect = this.vibrateBtn.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const radius = rect.width / 2;

                const distance = Math.sqrt(
                    Math.pow(e.clientX - centerX, 2) + 
                    Math.pow(e.clientY - centerY, 2)
                );

                return distance <= radius;
            }

            onTouchEnterButton(touchId) {
                if (!this.isVibrating) {
                    this.startVibration();
                }
                this.vibrateBtn.classList.add('active', 'hover');
                this.createWaveEffect();
            }

            onTouchExitButton(touchId) {
                // Check if any other touches are still inside
                const hasInsideTouch = Array.from(this.activeTouches.values())
                    .some(touch => touch.isInside);

                if (!hasInsideTouch && this.isVibrating) {
                    this.stopVibration();
                    this.vibrateBtn.classList.remove('active', 'hover');
                }
            }

            startVibration() {
                if (this.isVibrating) return;
                
                this.isVibrating = true;
                this.vibrateBtn.classList.add('vibrating');
                
                if (navigator.vibrate) {
                    // Continuous vibration pattern
                    this.vibrationInterval = setInterval(() => {
                        navigator.vibrate(50);
                    }, 100);
                    
                    this.showStatus('Vibrating... ðŸ“³');
                } else {
                    this.showStatus('Vibration not supported ðŸ˜•');
                }
            }

            stopVibration() {
                if (!this.isVibrating) return;
                
                this.isVibrating = false;
                this.vibrateBtn.classList.remove('vibrating');
                
                if (this.vibrationInterval) {
                    clearInterval(this.vibrationInterval);
                    this.vibrationInterval = null;
                }
                
                if (navigator.vibrate) {
                    navigator.vibrate(0);
                }
                
                this.showStatus('Stopped vibrating');
                setTimeout(() => {
                    this.hideStatus();
                }, 2000);
            }

            stopAllVibration() {
                this.activeTouches.clear();
                this.stopVibration();
                this.vibrateBtn.classList.remove('active', 'hover');
            }

            updateDebugInfo() {
                if (!this.debugMode) {
                    this.debugInfo.classList.remove('show');
                    return;
                }

                const touches = Array.from(this.activeTouches.entries());
                const touchInfo = touches.map(([id, state]) => 
                    `${id}: ${state.isInside ? 'IN' : 'OUT'} (${Math.round(state.x)},${Math.round(state.y)})`
                ).join('\n');

                this.debugInfo.innerHTML = `
                    Active Touches: ${touches.length}<br>
                    Vibrating: ${this.isVibrating}<br>
                    ${touchInfo.replace(/\n/g, '<br>')}
                `;
                this.debugInfo.classList.add('show');
            }

            checkVibrationSupport() {
                if (!navigator.vibrate) {
                    this.showStatus('Vibration API not supported on this device');
                }
            }

            showStatus(message) {
                this.status.textContent = message;
                this.status.classList.add('show');
            }

            hideStatus() {
                this.status.classList.remove('show');
            }

            showServiceWorkerStatus(message, duration = 3000) {
                this.swStatus.textContent = message;
                this.swStatus.classList.add('show');
                
                setTimeout(() => {
                    this.swStatus.classList.remove('show');
                }, duration);
            }

            createWaveEffect() {
                const wave = document.createElement('div');
                wave.className = 'wave';
                wave.style.left = '50%';
                wave.style.top = '50%';
                wave.style.width = '100px';
                wave.style.height = '100px';
                wave.style.marginLeft = '-50px';
                wave.style.marginTop = '-50px';
                
                document.querySelector('.background-animation').appendChild(wave);
                
                setTimeout(() => {
                    wave.remove();
                }, 3000);
            }

            createBackgroundAnimation() {
                const backgroundAnim = document.querySelector('.background-animation');
                
                setInterval(() => {
                    if (!this.isVibrating && Math.random() > 0.7) {
                        const wave = document.createElement('div');
                        wave.className = 'wave';
                        wave.style.left = Math.random() * 100 + '%';
                        wave.style.top = Math.random() * 100 + '%';
                        wave.style.width = '50px';
                        wave.style.height = '50px';
                        wave.style.marginLeft = '-25px';
                        wave.style.marginTop = '-25px';
                        
                        backgroundAnim.appendChild(wave);
                        
                        setTimeout(() => {
                            wave.remove();
                        }, 3000);
                    }
                }, 2000);
            }

            async setupPWA() {
                // Get the correct base path for GitHub Pages
                const basePath = this.getBasePath();
                
                // Register service worker - now using external file
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('./sw.js', {
                            scope: basePath
                        });
                        
                        console.log('Service Worker registered successfully:', registration);
                        this.showServiceWorkerStatus('âœ… Service Worker registered');
                        
                        // Handle service worker updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    this.showServiceWorkerStatus('ðŸ”„ App updated! Refresh to see changes', 5000);
                                }
                            });
                        });
                        
                    } catch (error) {
                        console.error('Service Worker registration failed:', error);
                        this.showServiceWorkerStatus('âŒ Service Worker registration failed');
                    }
                } else {
                    console.log('Service Workers not supported');
                    this.showServiceWorkerStatus('âš ï¸ Service Workers not supported');
                }

                // Handle install prompt
                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    this.deferredPrompt = e;
                    if (!this.isInstalled) {
                        setTimeout(() => this.showInstallPrompt(), 3000);
                    }
                });

                // Handle app installation
                window.addEventListener('appinstalled', () => {
                    console.log('PWA was installed');
                    this.isInstalled = true;
                    this.hideInstallPrompt();
                    this.showServiceWorkerStatus('ðŸŽ‰ App installed successfully!');
                });

                // Show install prompt for iOS Safari (after delay)
                if (this.isIOS() && !this.isStandalone() && !this.isInstalled) {
                    setTimeout(() => {
                        this.showInstallPrompt();
                    }, 5000);
                }
            }

            getBasePath() {
                // Get the correct base path for GitHub Pages
                const path = window.location.pathname;
                if (path.includes('.github.io/') && !path.endsWith('.github.io/')) {
                    // Extract repository name for GitHub Pages
                    const parts = path.split('/');
                    const repoIndex = parts.findIndex(part => part.includes('.github.io'));
                    if (repoIndex !== -1 && parts[repoIndex + 1]) {
                        return `/${parts[repoIndex + 1]}/`;
                    }
                }
                return './';
            }

            checkForServiceWorkerUpdates() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.ready.then(registration => {
                        registration.update();
                    });
                }
            }

            isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent);
            }

            isStandalone() {
                return window.matchMedia('(display-mode: standalone)').matches || 
                       window.navigator.standalone === true;
            }

            checkIfInstalled() {
                // Check if running as standalone (installed PWA)
                if (this.isStandalone()) {
                    this.isInstalled = true;
                    console.log('App is running as standalone (installed)');
                }
                
                // Check if beforeinstallprompt has been fired and dismissed
                if (localStorage.getItem('pwa-dismissed')) {
                    this.isInstalled = true;
                }
            }

            handleUrlActions() {
                // Handle URL parameters for shortcuts
                const urlParams = new URLSearchParams(window.location.search);
                const action = urlParams.get('action');
                
                if (action === 'vibrate') {
                    // Short vibration for shortcut
                    setTimeout(() => {
                        if (navigator.vibrate) {
                            navigator.vibrate([200, 100, 200]);
                            this.showStatus('Quick vibrate! ðŸ“³');
                        }
                    }, 500);
                }
            }

            showInstallPrompt() {
                if (!this.isInstalled) {
                    this.installPrompt.classList.add('show');
                }
            }

            hideInstallPrompt() {
                this.installPrompt.classList.remove('show');
                localStorage.setItem('pwa-dismissed', 'true');
            }

            async installPWA() {
                if (this.deferredPrompt) {
                    this.deferredPrompt.prompt();
                    const { outcome } = await this.deferredPrompt.userChoice;
                    
                    console.log(`User response to install prompt: ${outcome}`);
                    
                    if (outcome === 'accepted') {
                        this.isInstalled = true;
                        this.showServiceWorkerStatus('ðŸŽ‰ Installing app...');
                    }
                    
                    this.deferredPrompt = null;
                    this.hideInstallPrompt();
                } else if (this.isIOS()) {
                    // Show detailed iOS install instructions
                    const instructions = this.isInstalled ? 
                        'App is already added to your home screen!' :
                        'To install this app on iOS:\n\n1. Tap the Share button (âŽ‹) at the bottom of the screen\n2. Scroll down and tap "Add to Home Screen"\n3. Tap "Add" in the top right corner\n\nThe app will then appear on your home screen!';
                    
                    alert(instructions);
                    this.hideInstallPrompt();
                } else {
                    // For other browsers that don't support install prompt
                    this.hideInstallPrompt();
                    this.showServiceWorkerStatus('â„¹ï¸ Install not available on this browser');
                }
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new VibrationPWA();
        });

        // Prevent context menu on long press
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && navigator.vibrate) {
                navigator.vibrate(0); // Stop any ongoing vibration when page is hidden
            }
        });
    </script>
</body>
</html>